Virtual Blocks

PlacementSpec - list of excavations or placements to be applied to the world,
	along with configuration about how they should be applied. 
	
	Simple - spec for a single operation, the item stacks at each position
	may or may not represent the end world state, because of prior world state, 
	filter conditions or subsequent operations.  The spec and its entries
	contain the logic to transform current world (or virtual) block state
	into the specified state.  Persisted as part of a build.
	
	Build - spec that represents the end result of a committed build. The stack
	at each position is determined by taking real world state and applying
	all placement specs in the build in sequence. 
	
		This virtual state is stored in the virtual tracker for each active build
		and used for both rendering and placement. The virtual tracker
		handles execution of the end-state computation in a manner
		to prevent tick lag from large-scale operations.
		
		Job submissions for committed builds must wait for the virtual
		tracker to be caught up in computing virtual state before starting.
		
		Itemstack returned by this placement derived by comparing virtual state
		with real world state and determines what work needs to be done. 
		Will return an empty stack if no work is required, or the entry will
		be excluded entirely from the placement list.
		
		If the real world changes mid-job (not as a result of the job), 
		the survey will be redone and tasks altered as necessary.
		
		Build specs are persisted as part of their build mainly 
		so that identifiers and indexes retained in jobs remain consistent.

Build - collection of placement specs that are to applied in sequence and submitted as 
	a single job with a compiled placement spec.  Only a single build can be active
	(and thus visible) for each player.  Players can share a build.  Sharing a build
	means all players sharing it can see virtual blocks, make changes, and commit the build. 
	Builds can be saved or reloaded. 
	
	Builds are domain members and persisted as part of their domain. When a build is committed,
	all construction is managed by the domain of which it is a member. To share a build, a player 
	must be a member of the same domain and have building view/edit rights.  The player 
	can then switch to that domain and select the build as their active build.
	
	Each domain has a default build that is reopened whenever it is committed. By default,
	players use the default build of their active domain. Players in the same domain will
	thus all share the same default build unless they change their active build. 
	
	Builds do not interact with each other.  Players can only see a single build at a time.
	If two builds are built in the same physical space, the build that places second
	will apply the same logic it would if a falling block or other placement occurred
	after the build was started.
	
	Breaking a virtual block within an editable build removes the block entirely and is
	recorded as a single-block excavation operation. It does not change the operation
	that placed the block and CAN be undone.
	
	Using an excavation operation to remove physical blocks inside a build is also
	recorded as an excavation operation and can be undone.
	
	Removing a physical block by breaking it has no impact on the build except that some
	operations may have a different effect and it will allow a virtual blocks to placed
	if the build calls for a placement in the location of the removed block.
	
	Builds can be moved to a different location in the world.  Builds can also be copied.
	
	Once submitted for construction, a build cannot be changed.  
	Player can still view it, but clicking on blocks or other operations
	will inform the player the build is in construction and they have to reopen it to make changes.
	
	Builds submitted for construction can be reopened.  This cancels all active construction
	tasks.  The build is NOT changed, meaning that placed blocks are still part of the build
	but they will not render as placements or excavations because world state already matches.  
	
	A completed build can be re-submitted without changes for repair purposes.  
	This will cause the build to be re-applied exactly as before
	and any block state that not match virtual state will be changed.  Note that results can vary
	if excavations were not performed at the start.  For example, if a hollow shell was built without
	excavation the entire region, and the interior happened to be empty at last build time, a rebuild
	will not cause the interior to be excavated because that was never part of the build.
	
Jobs/Tasks
	When a build is committed, it creates a planning task that references the build.
	The planning task create excavate, procure/fab and placement
	tasks for each block position. This work is
	executed incrementally on the server thread during world tick.
	If a build is reopened, the entire job is cancelled.
	If in-scope world state changes outside of the job, (detected by virtual state tracker)
	these tasks are cancelled and the planning tasks is updated (if active) or made ready again.

Virtual Block Manager
	The virtual block manager maintains a buffer of current world state for all block positions
	affected by an active build. "Active" means that at least one online player has the build as their
	active (viewable) build OR that the build is being constructed, even if no player is currently viewing it.
	
	For each block position, the tracker maintains the list of builds affecting the position.
	
	The first time a block position is watched, the tracker retrieves the world state during
	the next server tick so that it can be used off-tick by builds.
	
	The tracker represents world state as ItemStacks instead of block states, to 
	facilitate comparison with compiled builds, which also represent world state
	as ItemStacks to be used for placement. 
	
	The tracker subscribes to block events and notifies builds when monitored world state
	changes to something other than what the build calls for.  
	
	The tracker maintains a list of virtual blocks that are or should be placed in the world.
	
	The tracker also handles the placement or removal of virtual blocks so that builds can
	be visualized. If *any* active build calls for a non-air block to be placed in an 
	air space, the tracker causes a virtual block to be placed there. When no build is active
	for a given position, any virtual block in that space will be removed.
	
	Client-side, virtual blocks will render the state of the current active build. If the 
	current active build does not apply to the space containing the virtual block, the
	virtual block will not render. Functionally, virtual blocks always behave identically to air.
	(Except they can be broken by player editing an active build.)  

	Builds are responsible for updating virtual state as the build changes, 
	and for sending client updates on build content for rendering.
	The tracker only maintains a buffer for the current world state that can be accessed 
	safely off-tick, and handles the placement and removal of virtual blocks.  
	
	Virtual state is not persisted - it is re-derived from virtual blocks and builds as
	they are loaded or created. 

Persistence Stuff

In tile entity
	deserializeNBT synonym for readFromNBT, AND ISN"T USED
	serializeNBT calls writeToNBT, ALSO NOT USED
	readFromNBT is called from create() static method
	
	Key takeaway is that support for ReadNBT / WriteNBT isn't going anywhere
	and methods should continue to be synonymous
	
	private tag customTileData is saved with tag "ForgeData" and is accesible
	via getTileData().  Is saved (if non-null) in writeInternal
	
	writeInternal is used by both writeToNBT/serializeNBT and getUpdateTag.  Only diff is that
	getUpdateTag returns a new tag vs writing to the passed in tag.  In both cases,
	there is no additional logic. writeInternal does not filter out anything for clients.
	
	getUpdateTag is used when chunk updates are sent - full or portial. 
	Does not seem useful for sending individual tile updates.
	
	handleUpdateTag is used on client to read in the packet produced by getUpdateTag.
	
	getUpdatePacket is used to send update packets for some vanilla blocks
	but comments in the code for the packet seem to indicate it should only
	be used by vanilla.  Default implementation returns null.
	
	onDataPacket is the client-side handler for the packet from getUpdatePacket()
	
	In summary - places were we need to avoid sending large NBT value to client
	that would break packets include:
		getUpdateTag / handleUpdateTag
		getUpdatePacket / onDataPacket (if used)
		
SuperTileEntity
	
	getUpdatePacket / onDataPacket
	---------------------------------
	implements getUpdatePacket / onDataPacket and sends entire tag
	called when there is a blockUpdate - tracked y PlayerChunkMap
	Note that only uses getUpdatePacket if there is a small number of 
	changes - otherwise seems to handle using getUpdateTag.
	Both use writeToNBT and so currently send full state. 
	
	In general is not efficient and could send overlarge packets if
	TE has a large NBT value. 

	But note also that modelState seldom changes unless the block state also changes,
	so this arrangement is probably fine for SuperBlocks.
	
	getUpdateTag / handleUpdateTag
	---------------------------------
	Works the same way as getUpdatePacket / onDataPacket
	Share the same handling routine on the client side, 
	which updates modelState and refreshes the client render state if different.
	
	readFromNBT / writeToNBT
	---------------------------------
	only addition is use of SuperBlockNBTHelper to read/write modelState.
	could instead make modelState implement IReadWriteNBT
	
	addInformation - change to use deserializers from stack NBT
	
	
	
	
	