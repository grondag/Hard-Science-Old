Virtual Blocks

PlacementSpec - list of placements to be applied to the world,
	along with configuration about how they should be applied. 
	
	Simple - spec for a single operation, the item stacks at each position
	may or may not represent the end world state, because of prior world state, 
	filter conditions or subsequent operations.  The spec and its entries
	contain the logic to transform current world (or virtual) block state
	into the specified state.  Persisted as part of a build.
	
	Build - spec that represents the end result of a committed build. The stack
	at each position is determined by capturing state of virtual blocks in the
	build at the time the spec is created.  
	
	Build specs are persisted as part of their build mainly 
	so that identifiers and indexes retained in jobs remain consistent.

Build - collection of virtual blocks being edited in the world, or to be placed
	in the world from a previously saved collection of virtual blocks.  
	
	Only a single build can be active (and thus visible) for each player.  
	
	Players can share an editable build.  
	Sharing a build means all players sharing it can see virtual blocks, 
	make changes, and commit the build.
	 
	Builds can be saved or unloaded or reloaded. 
	
	Builds are domain members and persisted as part of their domain. When a build is committed,
	all construction is managed by the domain of which it is a member. To share a build, a player 
	must be a member of the same domain and have building view/edit rights.  The player 
	can then switch to that domain and select the build as their active build.
	
	Each domain has a default build that is reopened whenever it is committed. By default,
	players use the default build of their active domain. Players in the same domain will
	thus all share the same default build unless they change their active build. 
	
	Builds can be moved to a different location in the world.  Builds can also be copied.
	
	Once submitted for construction, a build cannot be changed.  
	Player can still view it, but clicking on virtual blocks or other operations
	will inform the player the build is in construction and they have to reopen it to make changes.
	
	Builds submitted for construction can be reopened.  This cancels all active construction
	tasks.  The build is NOT changed, meaning that placed blocks are still part of the build
	but they will not render as placements or excavations because world state already matches.  
	
	A completed build can be re-submitted without changes for repair purposes.  
	This will cause the build to be re-applied exactly as before
	and any block state that not match virtual state will be changed.  Note that results can vary
	if excavations were not performed at the start.  For example, if a hollow shell was built without
	excavation the entire region, and the interior happened to be empty at last build time, a rebuild
	will not cause the interior to be excavated because that was never part of the build.
	
Jobs/Tasks
	When a build is committed, it creates a planning task that references the build.
	The planning task create excavate, procure/fab and placement
	tasks for each block position. This work is
	executed incrementally on the server thread during world tick.
	If a build is reopened, the entire job is cancelled.
	If in-scope world state changes outside of the job, (detected by virtual state tracker)
	these tasks are cancelled and the planning tasks is updated (if active) or made ready again.

Virtual Block (block)
	A virtual block represents the result of a virtual placement.
	
	All virtual blocks are associated with a build - either a build that is
	being edited or a build that has been placed and then marked with virtual blocks.
	
	A build that is being designed consists exclusively of virtual blocks.  Breaking
	or replacing a virtual block in a build being edited changes the build.
	
	A pre-designed build when placed in the world will only have virtual blocks
	in positions that are not occupied.  Breaking a virtual block in a pre-designed
	build that has been placed has no effect on the build - the block will still be placed.
	
	Virtual blocks are only visible if the player viewing them has selected the build associated
	with the virtual block as their active build.
	
	Placing a virtual block in a space already occupied by a virtual block from another build
	will depend on configuration.  It can either fail, or it will replace the virtual block
	and - if the replaced block was part of an editable build - change the build to which 
	the previous block belonged.
	
Tablet Computer (physical tool)
	Personal computer.  Required for all domain-related access functions and for viewing
	any kind of virtual reality construct, like virtual blocks or virtual tools. Player
	can upgrade to an implant version, which does not require an inventory slot and is accessed
	via a keystroke.
	
Excavation Marker (Virtual tool)
	Crafted using the tablet, marks real-world blocks for removal. Has several selection modes.
	All actions are immediately submitted as jobs.

Exchange Marker (Virtual tool)
	Crafted using the tablet, marks real-world blocks for replacement.  Has several selection modes. 
	All actions are immediately submitted as  jobs.
	
Excavation/Exchange Job (class instance)
	Job containing the excavation/exchange tasks submitted by the excavation/exchange markers. Part of a domain.
	Registers and updates excavation in the excavation render tracker, which handles client
	state. Must re-register with the render tracker on reload, because the tracker does not persist state.
	
Excavation Render Tracker (class)
	Tracks all excavation and exchange jobs in progress and transmits them to clients for rendering.
	Not serialized. Jobs are responsible for maintaining all state in the tracker.
	
Virtual Builder's Wand (Virtual tool)
	Crafted using the tablet, places virtual blocks similar to a builder's wand.  Selection can be
	based on either real-world or virtual blocks in the active build.  Placed blocks are part of
	the active build.

Virtual Cutter (Virtual tool)
	Removes virtual blocks, or parts of them, similar to an excavation marker but only affects
	virtual blocks in the current build.  Crafted using the tablet. Placed blocks are part of
	the active build.

Virtual Block (Virtual tool)
	Places virtual blocks in world, either singly or in multiblock shapes. Highly configurable.
	Crafted using the tablet. Placed blocks are part of the active build.
	Block placement actions are submitted as world tasks if the number of block state changes
	is large so they can be executed incrementally. 

World Task
	Interface to be supported by all job tasks that require world access.
	
	Similar to a runnable future, encapsulates some action that must be run during world tick.
	Each call to runTick() does work that should fit within a single tick and returns true if
	the task if complete. 
	
	
World Task Manager
	Maintains a queue of job tasks that require world access and executes them in FIFO order.  
	
	Ensures that all world access is synchronized, in-order, and does not exceed
	the configured threshold for points per tick.
	

Persistence Stuff

In tile entity
	deserializeNBT synonym for readFromNBT, AND ISN"T USED
	serializeNBT calls writeToNBT, ALSO NOT USED
	readFromNBT is called from create() static method
	
	Key takeaway is that support for ReadNBT / WriteNBT isn't going anywhere
	and methods should continue to be synonymous
	
	private tag customTileData is saved with tag "ForgeData" and is accesible
	via getTileData().  Is saved (if non-null) in writeInternal
	
	writeInternal is used by both writeToNBT/serializeNBT and getUpdateTag.  Only diff is that
	getUpdateTag returns a new tag vs writing to the passed in tag.  In both cases,
	there is no additional logic. writeInternal does not filter out anything for clients.
	
	getUpdateTag is used when chunk updates are sent - full or portial. 
	Does not seem useful for sending individual tile updates.
	
	handleUpdateTag is used on client to read in the packet produced by getUpdateTag.
	
	getUpdatePacket is used to send update packets for some vanilla blocks
	but comments in the code for the packet seem to indicate it should only
	be used by vanilla.  Default implementation returns null.
	
	onDataPacket is the client-side handler for the packet from getUpdatePacket()
	
	In summary - places were we need to avoid sending large NBT value to client
	that would break packets include:
		getUpdateTag / handleUpdateTag
		getUpdatePacket / onDataPacket (if used)
		
SuperTileEntity
	
	getUpdatePacket / onDataPacket
	---------------------------------
	implements getUpdatePacket / onDataPacket and sends entire tag
	called when there is a blockUpdate - tracked y PlayerChunkMap
	Note that only uses getUpdatePacket if there is a small number of 
	changes - otherwise seems to handle using getUpdateTag.
	Both use writeToNBT and so currently send full state. 
	
	In general is not efficient and could send overlarge packets if
	TE has a large NBT value. 

	But note also that modelState seldom changes unless the block state also changes,
	so this arrangement is probably fine for SuperBlocks.
	
	getUpdateTag / handleUpdateTag
	---------------------------------
	Works the same way as getUpdatePacket / onDataPacket
	Share the same handling routine on the client side, 
	which updates modelState and refreshes the client render state if different.
	
	readFromNBT / writeToNBT
	---------------------------------
	only addition is use of SuperBlockNBTHelper to read/write modelState.
	could instead make modelState implement IReadWriteNBT
	
	addInformation - change to use deserializers from stack NBT
	
	
	
	
	