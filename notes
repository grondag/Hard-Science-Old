Things to do

If acuity is enabled, store a simple list of paintedquads


Exotic Matter cleanups
Space hogs:
	QuadContainer - could condense, compact give up some accuracy for painted quads in the dispatched
					could also cache some components, remove any that don't apply to painted
					
	VertexCollector/VertexCollectorList
	
	Sound files - currently largest is close to 13MB
		Mojang uses 48K mono, 32bit float
		
 Consider different version / child class in terrain state to reduce memory usage when vertex calcs not needed
 Clean up Polygon stuff from .before
Lazy expanded block state  ISuperBlockState
	Use this in TerrainWorldAdapter
Try caching immutable polygons instead of baking them into LitBakedQuad (like UnpackedBakedQuad)?
clean up / reorg model state docs
 	make all model state methods final
 	clean up terrain state, use bit packer instead of current mess
 	clear out macports crap
simplify/clean up state caching
 consider using block color handler to reduce # of baked quads in memory (get color from block during chunk build)
 

// ideas
use face normal in original poly
don't create new vec3f instance tVec - use local vars instead
optimize compute face normal in concrete poly classes


 Serialize port layout in devices
 Let direct ports mate with direct ports to form device/device private links
 
 Material Handling
 	Bulk Container
 		various sizes (see matter cubes) can contain up to max.
 		Quantity stored is in NBT as nL
 		Stores Forge Liquids, which may be flowable solids
 	
 	Process
 		Can be discrete or continuous
 		Continuous have only bulk input and outputs, all are variable
 		Discrete have specific item inputs and fixed-amount bulk inputs/outputs
 	
 		Inputs
 		ItemConversion (w/ ItemPredicate) -> Bulk Resource
 		FluidConversion -> Bulk Resource
 		ItemPredicate (specific)
 		
 		Outputs
 		BulkResource -> Fluid
 		BulkResource -> Container (if not fluid or fluid transport unavailable)
 		ItemStack
 		 
 	JEI recipes...
 		Do not show bulk resources
 		For each bulk input show example BulkContainer or FluidStack
 		
 	
	FluidBuffer
		For any fluid (gas,liquid or flowable solid) input/or output
		Can input/output from pipes, bulk containers
		In rare cases, (sand) can accept non-bulk item stacks
 		If more than one fluid/item resource can fill a fluid buffer,
 		then a generic fluid must be defined to represent those mixed/generic ingredients.
		
 	ItemBuffer
 		For any input or output that is a discrete item stack
 	

Portable fluid tanks are independent devices
Portable fluid tanks have specific ports/fluids
Portable fluid tanks have carrier ports for their fluid type
Multi-block fluid tanks (later) have shared device instance
Catalytic synthesis blocks have ethylene and ammonia carrier ports

Outputs of CS include graphite, containerized resins, PE resin, other resins, fibers

How does containerized fluid transport work?
	Containers
		are always same size (1M3) - but may not be full
		are fluid-specific
		(future) may require refrigerated storage

	Demand side - input to a buffer
		If have fluid circuit, try it first
		If accept containers, search for containers in item storage
		If container is bigger than buffer, place partial container in item output buffer
		If no containers, post containerizer demand
			If later obtain fluid supply, cancel container demand
		
	Supply side - output from a buffer
		If have fluid circuit, search for available storage on it
		If can output to container, obtain a container and fill it
		Place filled containers in item output buffer
		If output is for a specific job, output container as soon as 
			it reaches the demanded amount.
		If no available containers, post demand for empty container
		
	Containerizers
		Import or export containerized fluid from an attached fluid circuit
		Two optional limits
			Min fill %/# - import containers if storage on local circuit falls below
			Max fill %/# - export containers if storage on local circuit falls below
			
		Parameters
			Accept export requests: will export a container on demand if above min
			
		
	Supply side
		
		If have a fluid circuits, and 

Storage Network

In PacketOpenContainerStorageInteraction.handle, use listener instead of storage
for resource handle cross reference.  TileEntity will need to save a reference
for listeners other than the domain-level listener.

Remove resource handle from resource.

Virtual Blocks

PlacementSpec - list of placements to be applied to the world,
	along with configuration about how they should be applied. 
	
	Simple - spec for a single operation, the item stacks at each position
	may or may not represent the end world state, because of prior world state, 
	filter conditions or subsequent operations.  The spec and its entries
	contain the logic to transform current world (or virtual) block state
	into the specified state.  Persisted as part of a build.
	
	Build - spec that represents the end result of a committed build. The stack
	at each position is determined by capturing state of virtual blocks in the
	build at the time the spec is created.  
	
	Build specs are persisted as part of their build mainly 
	so that identifiers and indexes retained in jobs remain consistent.

Build - collection of virtual blocks being edited in the world, or to be placed
	in the world from a previously saved collection of virtual blocks.  
	
	Only a single build can be active (and thus visible) for each player.  
	
	Players can share an editable build.  
	Sharing a build means all players sharing it can see virtual blocks, 
	make changes, and commit the build.
	 
	Builds can be saved or unloaded or reloaded. 
	
	Builds are domain members and persisted as part of their domain. When a build is committed,
	all construction is managed by the domain of which it is a member. To share a build, a player 
	must be a member of the same domain and have building view/edit rights.  The player 
	can then switch to that domain and select the build as their active build.
	
	Each domain has a default build that is reopened whenever it is committed. By default,
	players use the default build of their active domain. Players in the same domain will
	thus all share the same default build unless they change their active build. 
	
	Builds can be moved to a different location in the world.  Builds can also be copied.
	
	Once submitted for construction, a build cannot be changed.  
	Player can still view it, but clicking on virtual blocks or other operations
	will inform the player the build is in construction and they have to reopen it to make changes.
	
	Builds submitted for construction can be reopened.  This cancels all active construction
	tasks.  The build is NOT changed, meaning that placed blocks are still part of the build
	but they will not render as placements or excavations because world state already matches.  
	
	A completed build can be re-submitted without changes for repair purposes.  
	This will cause the build to be re-applied exactly as before
	and any block state that not match virtual state will be changed.  Note that results can vary
	if excavations were not performed at the start.  For example, if a hollow shell was built without
	excavation the entire region, and the interior happened to be empty at last build time, a rebuild
	will not cause the interior to be excavated because that was never part of the build.
	
Jobs/Tasks
	When a build is committed, it creates a planning task that references the build spec.
	The planning task create excavate, procure/fab and placement
	tasks for each block position. This work is
	executed incrementally on the server thread during world tick.
	If a build is reopened, the entire job is cancelled.
	If in-scope world state changes outside of the job, (detected by virtual state tracker)
	these tasks are cancelled and the planning tasks is updated (if active) or made ready again.

Virtual Block (block)
	A virtual block represents the result of a virtual placement.
	
	All virtual blocks are associated with a build - either a build that is
	being edited or a build that has been placed and then marked with virtual blocks.
	
	A build that is being designed consists exclusively of virtual blocks.  Breaking
	or replacing a virtual block in a build being edited changes the build.
	
	A pre-designed build when placed in the world will only have virtual blocks
	in positions that are not occupied.  Breaking a virtual block in a pre-designed
	build that has been placed has no effect on the build - the block will still be placed.
	
	Virtual blocks are only visible if the player viewing them has selected the build associated
	with the virtual block as their active build.
	
	Placing a virtual block in a space already occupied by a virtual block from another build
	will depend on configuration.  It can either fail, or it will replace the virtual block
	and - if the replaced block was part of an editable build - change the build to which 
	the previous block belonged.
	
Tablet Computer (physical tool)
	Personal computer.  Required for all domain-related access functions and for viewing
	any kind of virtual reality construct, like virtual blocks or virtual tools. Player
	can upgrade to an implant version, which does not require an inventory slot and is accessed
	via a keystroke.
	
Excavation Marker (Virtual tool)
	Crafted using the tablet, marks real-world blocks for removal. Has several selection modes.
	All actions are immediately submitted as jobs.

Exchange Marker (Virtual tool)
	Crafted using the tablet, marks real-world blocks for replacement.  Has several selection modes. 
	All actions are immediately submitted as  jobs.
	
Excavation/Exchange Job (class instance)
	Job containing the excavation/exchange tasks submitted by the excavation/exchange markers. Part of a domain.
	Registers and updates excavation in the excavation render tracker, which handles client
	state. Must re-register with the render tracker on reload, because the tracker does not persist state.
	
Excavation Render Tracker (class)
	Tracks all excavation and exchange jobs in progress and transmits them to clients for rendering.
	Not serialized. Jobs are responsible for maintaining all state in the tracker.
	
Virtual Builder's Wand (Virtual tool)
	Crafted using the tablet, places virtual blocks similar to a builder's wand.  Selection can be
	based on either real-world or virtual blocks in the active build.  Placed blocks are part of
	the active build.

Virtual Cutter (Virtual tool)
	Removes virtual blocks, or parts of them, similar to an excavation marker but only affects
	virtual blocks in the current build.  Crafted using the tablet. Placed blocks are part of
	the active build.

Virtual Block (Virtual tool)
	Places virtual blocks in world, either singly or in multiblock shapes. Highly configurable.
	Crafted using the tablet. Placed blocks are part of the active build.
	Block placement actions are submitted as world tasks if the number of block state changes
	is large so they can be executed incrementally. 

World Task
	(see code)
	
World Task Manager
 	(see code)

Persistence Stuff

In tile entity
	deserializeNBT synonym for readFromNBT, AND ISN"T USED
	serializeNBT calls writeToNBT, ALSO NOT USED
	readFromNBT is called from create() static method
	
	Key takeaway is that support for ReadNBT / WriteNBT isn't going anywhere
	and methods should continue to be synonymous
	
	private tag customTileData is saved with tag "ForgeData" and is accesible
	via getTileData().  Is saved (if non-null) in writeInternal
	
	writeInternal is used by both writeToNBT/serializeNBT and getUpdateTag.  Only diff is that
	getUpdateTag returns a new tag vs writing to the passed in tag.  In both cases,
	there is no additional logic. writeInternal does not filter out anything for clients.
	
	getUpdateTag is used when chunk updates are sent - full or portial. 
	Does not seem useful for sending individual tile updates.
	
	handleUpdateTag is used on client to read in the packet produced by getUpdateTag.
	
	getUpdatePacket is used to send update packets for some vanilla blocks
	but comments in the code for the packet seem to indicate it should only
	be used by vanilla.  Default implementation returns null.
	
	onDataPacket is the client-side handler for the packet from getUpdatePacket()
	
	In summary - places were we need to avoid sending large NBT value to client
	that would break packets include:
		getUpdateTag / handleUpdateTag
		getUpdatePacket / onDataPacket (if used)
		
SuperTileEntity
	
	getUpdatePacket / onDataPacket
	---------------------------------
	implements getUpdatePacket / onDataPacket and sends entire tag
	called when there is a blockUpdate - tracked y PlayerChunkMap
	Note that only uses getUpdatePacket if there is a small number of 
	changes - otherwise seems to handle using getUpdateTag.
	Both use writeToNBT and so currently send full state. 
	
	In general is not efficient and could send overlarge packets if
	TE has a large NBT value. 

	But note also that modelState seldom changes unless the block state also changes,
	so this arrangement is probably fine for SuperBlocks.
	
	getUpdateTag / handleUpdateTag
	---------------------------------
	Works the same way as getUpdatePacket / onDataPacket
	Share the same handling routine on the client side, 
	which updates modelState and refreshes the client render state if different.
	
	readFromNBT / writeToNBT
	---------------------------------
	only addition is use of SuperBlockNBTHelper to read/write modelState.
	could instead make modelState implement IReadWriteNBT
	
	addInformation - change to use deserializers from stack NBT
	
	
	
       // SCENARIO: SEARCH INVENTORY - CLIENT 
//        
//        // on client, will give search a session identifier that is passed back and forth to server to match incoming updates
//        LiveStorageSearch<StorageTypeStack> search = ClientStorageIndexProxy.beginLiveItemSearch("iron");
//        
//        //search must implement List<IResourceStack<>> to be used to display in tab bar
//        TabBar<IResourceStack<StorageTypeStack>> bar = new TabBar(search);
//        
//        
//        search.setSearchString("gold");
//        
//        
//        //server needs to close open session if player is no longer looking at the screen, in case this gets missed
//        // see player.openContainer
//        search.close();
//        
//        
//        // SCENARIO: SEARCH INVENTORY - SERVER
//        
//        // top-level calls will mirror client
//        LiveStorageSearch<StorageTypeStack> search = ServerStorageIndexProxy.beginLiveItemSearch("iron");
//            // called by above
//            StorageIndexProxy.addListenter(search);
//            
//        search.setSearchString("gold");
//        
//        search.close();
//            StorageIndexProxy.removeListenter(search);
//        
//        // assumes stacks can't be negative, called by StorageIndex when it gets updates
//        LiveStorageSearch.notifyOfChange(stack, isRemoved); 
//        
//        // called by individual storages
//        search.notifyOfChange(stack, isRemoved);
//        StorageIndexProxy.register(IStorage);
//        StorageIndexProxy.register(IStorage); // has to be called if goes offline
//        
//        
//        // SCENARIO: DISPLAY MACHINE STATUS - CLIENT 
//        LiveMachineStatus machineStatus = clientMachine.requestLiveStatus();
//        
//        // list resources buffered in the machine: materials, power, fluids, etc.
//        List<IResourceStack<?>> bufferedInputs = machineStatus.bufferedInputs();
//        List<IResourceStack<?>> bufferedOutputs = machineStatus.bufferedOutputs();
//        Job activeJob = machineStatus.activeJob();
//        RequestStatus status = activeJob.getStatus();
//        List<IResourceStack<?>> expectedInputs = activeJob.expectedInputs();
//        List<IResourceStack<?>> expectedOutputs = activeJob.expectedOutputs();
//        List<IResourceStack<?>> actualInputs = activeJob.actualInputs();
//        List<IResourceStack<?>> actualOutputs = activeJob.actualOutputs();
//        
//        
//        // SCENARIO: DISPLAY MACHINE STATUS - SERVER 
//        LiveMachineStatus machineStatus = serverMachine.requestLiveStatus();
//            serverMachine.addListener(machineStatus);
//        
//        // called in server machine on listeners when there is a change
//        machineStatus.checkForUpdates(this);
//        
//        
//        // SCENARIO: AUTOMATED BUILDING
//        
//        // user submits request to build a structure
//        BuildingPlan bPlan = myAdHocBuildTracker.createPlan();
//            List<BlockPlacement> placements = myAdHocBuildTracker.sequenceBlockPlacements();
//            
//            generateTasksForAllPlacements(List<BlockPlacement> placements)
//            {
//                for()
//            }
//            blockPlacement currentNode =
//            bPlan.addTopLevelTasks
//        myRecentBuildPlans.add(bPlan)
//        myAdHocBuildTracker.clear();
//        BuildingJob bJob = BuildingManager.createJob(bPlan);
//        
//                        
//        /**
//          
//          blocks require an queue selection agent"
//           useful when units of work have to pass through multiple processing steps with dependencies
//           that aren't part of the processing.  Block building is a good example.
//           We can make the blocks and load up drones, but blocks have to be placed on other blocks.
//           And the other blocks available to be placed on may change dynamically.
//           
//           Tasks in the queue are selected by the agent based on their ability to be consumed in the end.
//           In this case, agent checks to see if the block can be placed against a block already
//           in the world, or against a block that it has already promoted to a later step of processing.
//           
//           example
//           
//           placed 10 blocks
//           blocks 0-3 can be placed on the ground, or on each other
//           blocks 4-7 must be placed on one of the blocks 0-3, or on each other
//           blocks 8-9 must be placed on 4 and 7
//           
//           processing has three steps: forming, loading (into drone), and placing (moving drone and placing blocks)
//           
//           agent will immediately release blocks 0-3 for forming.
//           As those complete, they move the loading queue and agent will begin to release 4-7 for forming.
//           Drones can pick up as many blocks as they can from the loading queue
//           and then move to build site and start placing them.  Some risk of waiting if drones
//           get delayed or place blocks at different speeds, but probably okay.
//           
//           TaskContainer - container with tasks to be executed
//               scheduler - logic that determines which waiting tasks can be started
//               taskFactory - adapter that prepares inputs for execution by this container
//               limit - max number of items can be in queue before it stops accepting new items
//               inputContainer - container from which to pull work
//               takeCompleteTasks() - take completed work that can be drawn from this container
//               startReadyTask() - find a ready task, mark it started and return it
//               abortStartedTask(task) - return a started task to ready state
//               completeStartedTask(task) - move a started task to completed state
//               addCompletionListener() - will notify listeners when a task is completed
//               addReadyListener() - will notify listeners when a task is ready
//               
//               tasks in a container can be unready, ready, started or complete
//
//               taskContainers that use the same worker type will register
//               with a gobla index service that subscribes to addReadyListener()
//               so that workers can find tasks without querying individual jobs
//               
//               a machine or process that consumes the type of task in the container will try to claim ready tasks
//                   it will mark the task a started and then mark it complete when finished
//               only complete tasks can be taken by a downstream container
//               
//               container has a periodic upkeep loop
//                   if this.count < limit
//                       for input : inputContainer.takeCompletedTasks()
//                       {
//                           this.addTask(taskFactory.createTaskFromInput(input)
//                       }
//                   scheduler.schedule(this)       
//               
//           StartContainer - container with no inputs or scheduler
//               all tasks in a StartContainer have a complete status
//               typically no size limit
//                   
//           FinishContainer - container at the end of a job
//               taskFactory simply discards tasks and increments counters
//               no WIP limit
//               no scheduler
//               pulls completed tasks from upstream containers
//               and monitors job completion progress
//               
//           A construction job would look like this
//           
//           Schedulers
//               site scheduler - readies blocks that can be placed at construction site
//               fab scheduler - readies any blocks that can be placed on blocks that have completed fabrication 
//               load scheduler - readies any blocks that can be placed on blocks that have been loaded by a drone
//               
//           
//           FabricationContainer 
//               has no inputContainer
//               has all of the job's generic blockplacement tasks in unready status
//               compound scheduler (site or fab)
//               listeners: fab scheduler, fabrication manager
//               
//               the fabrication machines will manage their own logistics for building
//               the blocks.  The global fab index service provides a feasibilty and estimation function
//               for use by the construction planner.
//               
//           TransportContainer
//               FabricationContainer is input
//               factory simply creates a transport task to move completed blocks to the drone loading site
//               scheduler readies all jobs with no exclusion
//               tasks are marked complete when they arrive at loading site
//               transport subsystem handles sub-planning, execution and estimation of transport tasks
//               listeners: transport manager
//               
//            LoadContainer
//                TransportContainer is input
//                construction drones complete tasks by picking up blocks
//                compound scheduler: (site or load)
//                listeners: load scheduler, construction drone manager
//                
//            BuildContainer
//                LoadContainer is input
//                drones use this to report completion but manage the placement directly
//                no listeners, only used to report status
//                no scheduler, all tasks begin with started status
//                
//                
//            -----
//            
//            
//            so let's look at the processing subsystems that consume the tasks in each of these containers
//            
//            
//            FabricationManager
//                execute tasks that consume material inputs and process them into material outputs
//                also consumes power, computation and may consume transport resources
//                different FabManager for each type of fabrication (nano-fab, crushing, block forming, etc.)
//                Machines that perform multiple functions can be used by more than one FabricationManager
//                computes a preference score for each machine based on priorities
//                for tasks in queue, or being estimated, generates procurement orders for necessary inputs
//                may cancel or change procurement orders if a better way to fabricate something becomes available
//                when all material inputs are reserved, appended to processing queue (may be different priority buckets)
//                added to queue of machine with highest preference score
//                outputs may remain reserved for next step regardless of storage location
//                
//            ProcessingMachine
//                knows how to do one or more processing types
//                provides estimates of costs and outputs
//                scans queue for job tickets
//                expects ticket to have a reservation for all inputs
//                may maintain a buffer quantity of frequently used resources (power, resin, water, etc.)
//                issues transport requests for reserved material inputs when it can receive them
//                produces outputs, puts in output buffer, notifies caller of completion
//                if outputs are not removed from output buffer before it fills, may redirect them to storage  
//                
//            FabricationTask
//                specific to a fabrication type
//                task parameters (modelState, substance type, for example)
//                execute
//                getInputs 
//                procureInputs - called by FabManager when task is being readied to processing, reserves inputs
//                setInputReservations - called 
//                addListener - so that task can notify queue when inputs have been procured and is ready to process
//                getInputReservations - called by machine when it picks up task and is ready to receive inputs
//                setStatus - called by machine / manager to update status
//                setOututReservation - called by machine when reserved outputs are placed in buffer or storage
//                
//                
//            QUESTION: if an input is not in storage and must be fabricated to complete a fabrication task...
//                who issues the request to fabricate the input? FabManager, FabTask, ProcurmentManager?
//                Has to be Procurement, right? Because FabTask didn't know it wasn't available until
//                it asked the procurement manager for the material.
//                
//            StorageManagerImpl - what is stored and where?
//                issues transport requests to put things in storage - where should it be stored?
//                
//            ProcurementManager - who gets to use what is stored?
//                queues prioritized resource requests and apportions them 
//                reserves stored material for a particular task or purpose
//                relies on inventory manager to know what is stored and where
//                reservations aren't locale/lot specific for same material/itemstack 
//                    as example: machine outputs may not go to next task in job if equivalent outputs are closer
//                issues fabrication requests for materials that aren't available (not in storage or already reserved)
//                          
//         */
//        // user can request job status via mechanism similar to machines, see above
//        
//        
//        // forces work break down and may generate multiple possible plans
//        // removes any plans that have unmeetable external dependencies (inputs or conditions that don't come from a task within the plan)
//        // this includes availability of raw materials, production capacity, drone capacity, etc
//        // Then selects the best available plan according to current strategic stance set by user
//        //  Tradeoffs in stance are by function (building, defense, etc.) and choices are speed, efficiency (cost), quality (may not apply for all)
//        // Then makes best plan the active plan.  Or sets no active plan if there are no feasible plans.
//        // Can be called on a job that is already active.  
//        // Doing so will consider only current resources and incomplete tasks 
//        bJob.plan();
//        
//        
//        /**
//        / sample optimization problems
//         * 
//         * several tasks can be completed on two different machines
//         * for all tasks, one of the machines will be most efficient at task level
//         * if all tasks use the single machine, there will be delay overall
//         * would only accept this delay if efficiency is top priority
//         * 
//         * handle this by deciding at last possible moment
//         * each production task has a single provider queue that will route work dynamically based on priorties
//         * plan WBS only needs to know if the task is *possible* and have an estimate (based on recent history) of production cost
//         * plan will be refined at the task level as work gets done
//         * 
//         * another example, a job needs iron and there are four possible ways to get iron
//         * 1) use existing on-hand
//         * 2) conventional ore mining / processing
//         * 
//         * Above illustrates key point for fungible resources - iron, water, power, etc that may have multiple
//         * different forms (blocks/ingots, tanks/on-demand/containerized,  joules/fuel).
//         * All forms of a fungible resource are treated as a single dependency/task for dependent tasks.  
//         * The actual production method will be dynamically determined and may vary within the same job.
//         * 
//         * Fungible resources are only counted as fungible if a 2-way conversion method exists.
//         * (It may have its own dependencies on machines, power, etc.)
//         * The coversion of the fungible resources will have its own sub-plan that is dynamically managed.
//         * 
//         * Producible resources have at least one automated production method that consumes time, machine capacity and/or other resources.
//         * A non-producible resource has to be obtained by the player. 
//         * If a plan requires non-producible resource not in inventory, the plan is not viable.
//         * 
//         * Reclaimable resources can be broken down into other resources that are ingredients in the reclaimable resource.
//         * The output of reclaimation are never included in plans to avoid introducing cycles.  
//         * Instead, if a reclaimable resource has a minimum stocking unit level and the level in storage
//         * drops below this, the excess will be automatically reclaimed.
//         * 
//         * For example, suppose salt and water make brine, and brine can be converted back to solt and water.
//         * Suppose a process needs both water and brine as inputs.  It will use brine on hand, and it will make
//         * brine if some is needed, but it will not produce water from brine as part of the job.  It will
//         * instead rely on reclamation to reclaim excess brine as a separate management function.
//         * 
//         * If more than one, non-fungible resource can be used to produce something, and one of the resources
//         * is non-producible and has other uses, the planner may consume the producible resource, even if the non-producible resource is on hand.
//         * This should probably be a strategy setting, or an inventory setting for the item itself, like minimum stocking level.
//         * 
			  Late add: do we need Resource Brokers to manage/optimize commodity and convertible resources?

//        */
//        
//         // To plan our construction job, we work backwards:
//          
//         // The construction task requires a drone and a block, both at a certain location.
//         Plan newPlan = new Plan(bJob.jobTask);
//         
//         // ... in plan constructor
//         newPlan.topLevelTask = jobTask;
//         jobTask.planSubtasks();
//         
//         // construction task will generate these subtasks...
//         mySubtasks.add(new DroneTask())
//         
//
//        // determine loosely sequenced production plan for optimal construction
//        
//        // determine resource availability and sub-production plan
//        
//        // submit production requests to queue, with dependences
//        
//        
//        // submit construction requests to queue, with dependencies on production requests
//        // and, if appropriate, other construction requests
	
	